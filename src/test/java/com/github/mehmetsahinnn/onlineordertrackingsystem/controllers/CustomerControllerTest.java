package com.github.mehmetsahinnn.onlineordertrackingsystem.controllers;import com.github.mehmetsahinnn.onlineordertrackingsystem.config.KeycloakClient;import com.github.mehmetsahinnn.onlineordertrackingsystem.enums.AccountStatus;import com.github.mehmetsahinnn.onlineordertrackingsystem.models.Customer;import com.github.mehmetsahinnn.onlineordertrackingsystem.services.CustomerService;import com.github.mehmetsahinnn.onlineordertrackingsystem.security.PCrypt;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.MockitoAnnotations;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import java.util.Collections;import java.util.List;import java.util.Map;import static org.junit.jupiter.api.Assertions.*;import static org.mockito.ArgumentMatchers.anyString;import static org.mockito.Mockito.*;/** * Unit tests for the CustomerController class. */class CustomerControllerTest {    @Mock    private CustomerService customerService;    @Mock    private PCrypt crypt;    @InjectMocks    private CustomerController customerController;    /**     * Initializes Mockito annotations before each test method.     */    @BeforeEach    public void init() {        try (AutoCloseable ac = MockitoAnnotations.openMocks(this)) {            Customer customer = new Customer();            when(customerService.getCurrentUser()).thenReturn(customer);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    /**     * Tests the login method of CustomerController with valid credentials.     * Verifies that the response status is OK and the customer object is returned.     *///    @Test//    public void test_valid_email_and_password_return_jwt_token() {//        // Arrange//        CustomerService customerService = mock(CustomerService.class);//        PCrypt crypt = mock(PCrypt.class);//        KeycloakClient keycloakClient = mock(KeycloakClient.class);//        CustomerController customerController = new CustomerController(customerService, crypt, keycloakClient);////        Customer customerLoginDetails = new Customer();//        customerLoginDetails.setEmail("test@example.com");//        customerLoginDetails.setPassword("password");////        Customer customer = new Customer();//        customer.setEmail("test@example.com");//        customer.setPassword("encodedPassword");////        BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();////        when(customerService.findByEmail("test@example.com")).thenReturn(customer);//        when(crypt.passwordEncoder()).thenReturn(bCryptPasswordEncoder);//        when(bCryptPasswordEncoder.matches("password", "encodedPassword")).thenReturn(true);//        when(keycloakClient.getLoginToken("test@example.com", "encodedPassword")).thenReturn("jwtToken");////        // Act//        ResponseEntity<?> response = customerController.login(customerLoginDetails);////        // Assert//        assertEquals(HttpStatus.OK, response.getStatusCode());//        Map<String, Object> responseBody = (Map<String, Object>) response.getBody();//        assertNotNull(responseBody);//        assertEquals("Logged In", responseBody.get("message"));//        Map<String, Object> data = (Map<String, Object>) responseBody.get("data");//        assertEquals("jwtToken", data.get("token"));////    }    /**     * Tests the login method of CustomerController with invalid credentials.     * Verifies that the response status is UNAUTHORIZED and the appropriate message is returned.     */    @Test    public void testLoginInvalidCredentials() {        when(customerService.findByEmail(anyString())).thenReturn(null);        ResponseEntity<?> responseEntity = customerController.login(new Customer(1L,"msa","hin","sda","password","john.doess@example.com",AccountStatus.USER));        assertEquals(HttpStatus.UNAUTHORIZED, responseEntity.getStatusCode());        assertEquals("Invalid email or password", responseEntity.getBody());    }    /**     * Tests the registerUser method of CustomerController when registration is successful.     * Verifies that the response status is OK and the registration process is invoked.     */    @Test    public void testRegisterUserSuccess() {        Customer customer = new Customer(1L,"msa","hin","Oak","password","josh.doe@example.com", AccountStatus.USER);        doNothing().when(customerService).registerNewCustomer(customer);        ResponseEntity<?> responseEntity = customerController.registerUser(customer);        assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());        verify(customerService, times(1)).registerNewCustomer(customer);    }    /**     * Tests the registerUser method of CustomerController when user already exists.     * Verifies that the response status is CONFLICT and the appropriate message is returned.     */    @Test    public void testRegisterUserAlreadyExists() {        Customer customer = new Customer();        doThrow(new RuntimeException("User Already Exists !")).when(customerService).registerNewCustomer(customer);        ResponseEntity<?> responseEntity = customerController.registerUser(customer);        assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());    }    /**     * Tests the listCustomers method of CustomerController when listing customers is successful.     * Verifies that the response status is OK and the list of customers is returned.     *///    @Test//    public void testListCustomers_Success() {//        List<Customer> customers = Collections.singletonList(new Customer(1L,"msa","hin","Oak","password","josh.doe@example.com", AccountStatus.USER));//        when(customerService.findAll()).thenReturn(customers);////        ResponseEntity<?> responseEntity = customerController.listCustomers();////        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());//        assertEquals(customers, responseEntity.getBody());//    }    /**     * Tests the deleteById method of CustomerController.     * Verifies that the response status is NO_CONTENT after successfully deleting a customer.     */    @Test    public void testDeleteCustomer(){        Customer customer = new Customer();        customer.setId(1L);        customer.setName("Jack");        customer.setSurname("Names");        ResponseEntity<?> response = customerController.deleteById(customer.getId());        assertEquals(HttpStatus.OK, response.getStatusCode());        assertNull(response.getBody());    }}